  
 <html>
   <head>
      <title>Live sensor data</title>

      <style type="text/css">
      #datatable {
          border:2px solid #999;
          font-family:verdana,arial,helvetica,sans-serif;
          margin:auto;
          width:1000px;
      }
      #datatable td{
          width:50px;
          font-size:14px;
          border:1px solid #000;
          text-align:center;
      }
      #datatable th{
          width:50px;
          font-size:16px;
          background-color:#999;
          border:2px solid #999;
          text-align:center;
      }
      </style>


      <script>
/*
 AutobahnJS - http://autobahn.ws

 Copyright 2011, 2012 Tavendo GmbH.
 Licensed under the MIT License.
 See license text at http://www.opensource.org/licenses/mit-license.php

 AutobahnJS includes code from:

 when - http://cujojs.com

 (c) copyright B Cavalier & J Hann
 Licensed under the MIT License at:
 http://www.opensource.org/licenses/mit-license.php

 Crypto-JS - http://code.google.com/p/crypto-js/

 (c) 2009-2012 by Jeff Mott. All rights reserved.
 Licensed under the New BSD License at:
 http://code.google.com/p/crypto-js/wiki/License
*/
/*
 MIT License (c) copyright B Cavalier & J Hann */
(function(a){a(function(){function a(){}function e(){}function d(a){var d=new e;d.then=function(d){f(arguments);var c;try{return d&&(c=d(a)),j(c===q?a:c)}catch(e){return b(e)}};return o(d)}function b(a){var d=new e;d.then=function(d,c){f(arguments);var e;try{return c?(e=c(a),j(e===q?a:e)):b(a)}catch(g){return b(g)}};return o(d)}function f(a){for(var b,d=a.length;d;)if(b=a[--d],null!=b&&"function"!=typeof b)throw Error("callback is not a function");}function h(){var a,c,g,m,i,j,k;g=[];m=[];i=function(a,
b,d){f(arguments);var c=h();g.push(function(d){d.then(a,b).then(c.resolve,c.reject,c.progress)});d&&m.push(d);return c.promise};j=function(a){for(var d,b=0;d=m[b++];)d(a)};k=function(a){var d,b=0;i=a.then;k=j=function(){throw Error("already completed");};for(m=q;d=g[b++];)d(a);g=[]};a={};c=new e;c.then=a.then=function(a,d,b){return i(a,d,b)};a.promise=o(c);a.resolver=o({resolve:a.resolve=function(a){k(d(a))},reject:a.reject=function(a){k(b(a))},progress:a.progress=function(a){j(a)}});return a}function g(a){return a&&
"function"===typeof a.then}function i(a,d,b,f){return j(a).then(d,b,f)}function j(a){var d;a instanceof e||(d=h(),g(a)?a.then(d.resolve,d.reject,d.progress):d.resolve(a),a=d.promise);return a}function k(d,b,f,e,g){function j(a){q(a)}function k(a){w(a)}function p(a){x(a)}var o,n,l,q,w,x,y;y=d.length>>>0;o=Math.max(0,Math.min(b,y));n=[];l=h();b=i(l,f,e,g);if(o){q=function(d){n.push(d);--o||(q=w=x=a,l.resolve(n))};w=function(d){q=w=x=a;l.reject(d)};x=l.progress;for(f=0;f<y;++f)f in d&&i(d[f],j,k,p)}else l.resolve(n);
return b}function l(a,d,b){a[b]=d;return a}function n(a,d,b){var f,c;f=a.length;c=[function(a,b,c){return i(a,function(a){return i(b,function(b){return d(a,b,c,f)})})}];3<=arguments.length&&c.push(b);return j(p.apply(a,c))}var o,p,q;o=Object.freeze||function(a){return a};p=[].reduce||function(a){var d,b,f,c,e;e=0;d=Object(this);c=d.length>>>0;b=arguments;if(1>=b.length)for(;;){if(e in d){f=d[e++];break}if(++e>=c)throw new TypeError;}else f=b[1];for(;e<c;++e)e in d&&(f=a(f,d[e],e,d));return f};i.defer=
h;i.isPromise=g;i.some=k;i.all=function(a,d,b,f){a=n(a,l,Array(a.length));return i(a,d,b,f)};i.any=function(a,d,b,f){return k(a,1,function(a){return d(a[0])},b,f)};i.reduce=n;i.map=function(a,d){var b,f;f=a.length;for(b=Array(f);0<=f;--f)f in a&&(b[f]=i(a[f],d));return n(b,l,b)};i.chain=function(a,d,f){var c=2<arguments.length;return i(a,function(a){c&&(a=f);d.resolve(a);return a},function(a){d.reject(a);return b(a)},d.progress)};return i})})("function"==typeof define?define:function(a){"undefined"!=
typeof module?module.exports=a():this.when=a()});("undefined"==typeof Crypto||!Crypto.util)&&function(){var a=window.Crypto={},c=a.util={rotl:function(a,b){return a<<b|a>>>32-b},rotr:function(a,b){return a<<32-b|a>>>b},endian:function(a){if(a.constructor==Number)return c.rotl(a,8)&16711935|c.rotl(a,24)&4278255360;for(var b=0;b<a.length;b++)a[b]=c.endian(a[b]);return a},randomBytes:function(a){for(var b=[];0<a;a--)b.push(Math.floor(256*Math.random()));return b},bytesToWords:function(a){for(var b=[],f=0,c=0;f<a.length;f++,c+=8)b[c>>>5]|=(a[f]&255)<<
24-c%32;return b},wordsToBytes:function(a){for(var b=[],f=0;f<32*a.length;f+=8)b.push(a[f>>>5]>>>24-f%32&255);return b},bytesToHex:function(a){for(var b=[],f=0;f<a.length;f++)b.push((a[f]>>>4).toString(16)),b.push((a[f]&15).toString(16));return b.join("")},hexToBytes:function(a){for(var b=[],f=0;f<a.length;f+=2)b.push(parseInt(a.substr(f,2),16));return b},bytesToBase64:function(a){if("function"==typeof btoa)return btoa(e.bytesToString(a));for(var b=[],f=0;f<a.length;f+=3)for(var c=a[f]<<16|a[f+1]<<
8|a[f+2],g=0;4>g;g++)8*f+6*g<=8*a.length?b.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c>>>6*(3-g)&63)):b.push("=");return b.join("")},base64ToBytes:function(a){if("function"==typeof atob)return e.stringToBytes(atob(a));for(var a=a.replace(/[^A-Z0-9+\/]/ig,""),b=[],f=0,c=0;f<a.length;c=++f%4)0!=c&&b.push(("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f-1))&Math.pow(2,-2*c+8)-1)<<2*c|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(f))>>>
6-2*c);return b}},a=a.charenc={};a.UTF8={stringToBytes:function(a){return e.stringToBytes(unescape(encodeURIComponent(a)))},bytesToString:function(a){return decodeURIComponent(escape(e.bytesToString(a)))}};var e=a.Binary={stringToBytes:function(a){for(var b=[],f=0;f<a.length;f++)b.push(a.charCodeAt(f)&255);return b},bytesToString:function(a){for(var b=[],f=0;f<a.length;f++)b.push(String.fromCharCode(a[f]));return b.join("")}}}();("undefined"==typeof Crypto||!Crypto.util)&&function(){var a=window.Crypto={},c=a.util={rotl:function(a,b){return a<<b|a>>>32-b},rotr:function(a,b){return a<<32-b|a>>>b},endian:function(a){if(a.constructor==Number)return c.rotl(a,8)&16711935|c.rotl(a,24)&4278255360;for(var b=0;b<a.length;b++)a[b]=c.endian(a[b]);return a},randomBytes:function(a){for(var b=[];0<a;a--)b.push(Math.floor(256*Math.random()));return b},bytesToWords:function(a){for(var b=[],f=0,c=0;f<a.length;f++,c+=8)b[c>>>5]|=(a[f]&255)<<
24-c%32;return b},wordsToBytes:function(a){for(var b=[],f=0;f<32*a.length;f+=8)b.push(a[f>>>5]>>>24-f%32&255);return b},bytesToHex:function(a){for(var b=[],f=0;f<a.length;f++)b.push((a[f]>>>4).toString(16)),b.push((a[f]&15).toString(16));return b.join("")},hexToBytes:function(a){for(var b=[],f=0;f<a.length;f+=2)b.push(parseInt(a.substr(f,2),16));return b},bytesToBase64:function(a){if("function"==typeof btoa)return btoa(e.bytesToString(a));for(var b=[],f=0;f<a.length;f+=3)for(var c=a[f]<<16|a[f+1]<<
8|a[f+2],g=0;4>g;g++)8*f+6*g<=8*a.length?b.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c>>>6*(3-g)&63)):b.push("=");return b.join("")},base64ToBytes:function(a){if("function"==typeof atob)return e.stringToBytes(atob(a));for(var a=a.replace(/[^A-Z0-9+\/]/ig,""),b=[],c=0,h=0;c<a.length;h=++c%4)0!=h&&b.push(("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(c-1))&Math.pow(2,-2*h+8)-1)<<2*h|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a.charAt(c))>>>
6-2*h);return b}},a=a.charenc={};a.UTF8={stringToBytes:function(a){return e.stringToBytes(unescape(encodeURIComponent(a)))},bytesToString:function(a){return decodeURIComponent(escape(e.bytesToString(a)))}};var e=a.Binary={stringToBytes:function(a){for(var b=[],c=0;c<a.length;c++)b.push(a.charCodeAt(c)&255);return b},bytesToString:function(a){for(var b=[],c=0;c<a.length;c++)b.push(String.fromCharCode(a[c]));return b.join("")}}}();
(function(){var a=Crypto,c=a.util,e=a.charenc,d=e.UTF8,b=e.Binary,f=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,
2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],h=a.SHA256=function(a,f){var d=c.wordsToBytes(h._sha256(a));return f&&f.asBytes?d:f&&f.asString?b.bytesToString(d):c.bytesToHex(d)};h._sha256=function(a){a.constructor==String&&(a=d.stringToBytes(a));var b=c.bytesToWords(a),e=8*a.length,a=[1779033703,3144134277,
1013904242,2773480762,1359893119,2600822924,528734635,1541459225],h=[],l,n,o,p,q,t,v,u,m,s,r;b[e>>5]|=128<<24-e%32;b[(e+64>>9<<4)+15]=e;for(u=0;u<b.length;u+=16){e=a[0];l=a[1];n=a[2];o=a[3];p=a[4];q=a[5];t=a[6];v=a[7];for(m=0;64>m;m++){16>m?h[m]=b[m+u]:(s=h[m-15],r=h[m-2],h[m]=((s<<25|s>>>7)^(s<<14|s>>>18)^s>>>3)+(h[m-7]>>>0)+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+(h[m-16]>>>0));r=e&l^e&n^l&n;var z=(e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22);s=(v>>>0)+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+
(p&q^~p&t)+f[m]+(h[m]>>>0);r=z+r;v=t;t=q;q=p;p=o+s>>>0;o=n;n=l;l=e;e=s+r>>>0}a[0]+=e;a[1]+=l;a[2]+=n;a[3]+=o;a[4]+=p;a[5]+=q;a[6]+=t;a[7]+=v}return a};h._blocksize=16;h._digestsize=32})();
(function(){var a=Crypto,c=a.util,e=a.charenc,d=e.UTF8,b=e.Binary;a.HMAC=function(a,e,g,i){e.constructor==String&&(e=d.stringToBytes(e));g.constructor==String&&(g=d.stringToBytes(g));g.length>4*a._blocksize&&(g=a(g,{asBytes:!0}));for(var j=g.slice(0),g=g.slice(0),k=0;k<4*a._blocksize;k++)j[k]^=92,g[k]^=54;a=a(j.concat(a(g.concat(e),{asBytes:!0})),{asBytes:!0});return i&&i.asBytes?a:i&&i.asString?b.bytesToString(a):c.bytesToHex(a)}})();/*
 MIT License (c) 2011,2012 Copyright Tavendo GmbH. */
var AUTOBAHNJS_VERSION="0.7.1",AUTOBAHNJS_DEBUG=!1,ab=window.ab={};ab._version=AUTOBAHNJS_VERSION;
(function(){Array.prototype.indexOf||(Array.prototype.indexOf=function(a){if(null===this)throw new TypeError;var c=Object(this),e=c.length>>>0;if(0===e)return-1;var d=0;0<arguments.length&&(d=Number(arguments[1]),d!==d?d=0:0!==d&&Infinity!==d&&-Infinity!==d&&(d=(0<d||-1)*Math.floor(Math.abs(d))));if(d>=e)return-1;for(d=0<=d?d:Math.max(e-Math.abs(d),0);d<e;d++)if(d in c&&c[d]===a)return d;return-1});Array.prototype.forEach||(Array.prototype.forEach=function(a,c){var e,d;if(this===null)throw new TypeError(" this is null or not defined");
var b=Object(this),f=b.length>>>0;if({}.toString.call(a)!=="[object Function]")throw new TypeError(a+" is not a function");c&&(e=c);for(d=0;d<f;){var h;if(d in b){h=b[d];a.call(e,h,d,b)}d++}})})();ab._sliceUserAgent=function(a,c,e){var d=[],b=navigator.userAgent,a=b.indexOf(a),c=b.indexOf(c,a);0>c&&(c=b.length);e=b.slice(a,c).split(e);b=e[1].split(".");for(c=0;c<b.length;++c)d.push(parseInt(b[c],10));return{name:e[0],version:d}};
ab.getBrowser=function(){var a=navigator.userAgent;return-1<a.indexOf("Chrome")?ab._sliceUserAgent("Chrome"," ","/"):-1<a.indexOf("Safari")?ab._sliceUserAgent("Safari"," ","/"):-1<a.indexOf("Firefox")?ab._sliceUserAgent("Firefox"," ","/"):-1<a.indexOf("MSIE")?ab._sliceUserAgent("MSIE",";"," "):null};ab.browserNotSupportedMessage="Browser does not support WebSockets (RFC6455)";ab._idchars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";ab._idlen=16;ab._subprotocol="wamp";
ab._newid=function(){for(var a="",c=0;c<ab._idlen;c+=1)a+=ab._idchars.charAt(Math.floor(Math.random()*ab._idchars.length));return a};ab.log=function(a){if(window.console&&console.log)if(1<arguments.length){console.group("Log Item");for(var c=0;c<arguments.length;c+=1)console.log(arguments[c]);console.groupEnd()}else console.log(arguments[0])};ab._debugrpc=!1;ab._debugpubsub=!1;ab._debugws=!1;
ab.debug=function(a,c){if("console"in window)ab._debugrpc=a,ab._debugpubsub=a,ab._debugws=c;else throw"browser does not support console object";};ab.version=function(){return ab._version};ab.PrefixMap=function(){this._index={};this._rindex={}};ab.PrefixMap.prototype.get=function(a){return this._index[a]};ab.PrefixMap.prototype.set=function(a,c){this._index[a]=c;this._rindex[c]=a};ab.PrefixMap.prototype.setDefault=function(a){this._index[""]=a;this._rindex[a]=""};
ab.PrefixMap.prototype.remove=function(a){var c=this._index[a];c&&(delete this._index[a],delete this._rindex[c])};ab.PrefixMap.prototype.resolve=function(a,c){var e=a.indexOf(":");if(0<=e){var d=a.substring(0,e);if(this._index[d])return this._index[d]+a.substring(e+1)}return!0==c?a:null};ab.PrefixMap.prototype.shrink=function(a,c){for(var e=a.length;0<e;e-=1){var d=this._rindex[a.substring(0,e)];if(d)return d+":"+a.substring(e)}return!0==c?a:null};ab._MESSAGE_TYPEID_WELCOME=0;
ab._MESSAGE_TYPEID_PREFIX=1;ab._MESSAGE_TYPEID_CALL=2;ab._MESSAGE_TYPEID_CALL_RESULT=3;ab._MESSAGE_TYPEID_CALL_ERROR=4;ab._MESSAGE_TYPEID_SUBSCRIBE=5;ab._MESSAGE_TYPEID_UNSUBSCRIBE=6;ab._MESSAGE_TYPEID_PUBLISH=7;ab._MESSAGE_TYPEID_EVENT=8;ab.CONNECTION_CLOSED=0;ab.CONNECTION_LOST=1;ab.CONNECTION_RETRIES_EXCEEDED=2;ab.CONNECTION_UNREACHABLE=3;ab.CONNECTION_UNSUPPORTED=4;ab.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT=5;ab.CONNECTION_LOST_SCHEDULED_RECONNECT=6;ab._Deferred=when.defer;
ab._construct=function(a,c){return"WebSocket"in window?new WebSocket(a,c):"MozWebSocket"in window?new MozWebSocket(a,c):null};
ab.Session=function(a,c,e,d){var b=this;b._wsuri=a;b._options=d;b._websocket_onopen=c;b._websocket_onclose=e;b._websocket=null;b._websocket_connected=!1;b._session_id=null;b._wamp_version=null;b._server=null;b._calls={};b._subscriptions={};b._prefixes=new ab.PrefixMap;b._txcnt=0;b._rxcnt=0;b._websocket=ab._construct(b._wsuri,[ab._subprotocol]);if(!b._websocket){if(void 0!==e){e(ab.CONNECTION_UNSUPPORTED);return}throw ab.browserNotSupportedMessage;}b._websocket.onmessage=function(a){ab._debugws&&(b._rxcnt+=
1,console.group("WS Receive"),console.info(b._wsuri+"  ["+b._session_id+"]"),console.log(b._rxcnt),console.log(a.data),console.groupEnd());a=JSON.parse(a.data);if(a[1]in b._calls){if(a[0]===ab._MESSAGE_TYPEID_CALL_RESULT){var c=b._calls[a[1]],d=a[2];if(ab._debugrpc&&void 0!==c._ab_callobj){console.group("WAMP Call",c._ab_callobj[2]);console.timeEnd(c._ab_tid);console.group("Arguments");for(var e=3;e<c._ab_callobj.length;e+=1){var j=c._ab_callobj[e];if(void 0!==j)console.log(j);else break}console.groupEnd();
console.group("Result");console.log(d);console.groupEnd();console.groupEnd()}c.resolve(d)}else if(a[0]===ab._MESSAGE_TYPEID_CALL_ERROR){c=b._calls[a[1]];d=a[2];e=a[3];j=a[4];if(ab._debugrpc&&void 0!==c._ab_callobj){console.group("WAMP Call",c._ab_callobj[2]);console.timeEnd(c._ab_tid);console.group("Arguments");for(var k=3;k<c._ab_callobj.length;k+=1){var l=c._ab_callobj[k];if(void 0!==l)console.log(l);else break}console.groupEnd();console.group("Error");console.log(d);console.log(e);void 0!==j&&
console.log(j);console.groupEnd();console.groupEnd()}void 0!==j?c.reject({uri:d,desc:e,detail:j}):c.reject({uri:d,desc:e})}delete b._calls[a[1]]}else if(a[0]===ab._MESSAGE_TYPEID_EVENT){if(c=b._prefixes.resolve(a[1],!0),c in b._subscriptions){var n=a[1],o=a[2];ab._debugpubsub&&(console.group("WAMP Event"),console.info(b._wsuri+"  ["+b._session_id+"]"),console.log(n),console.log(o),console.groupEnd());b._subscriptions[c].forEach(function(a){a(n,o)})}}else if(a[0]===ab._MESSAGE_TYPEID_WELCOME)if(null===
b._session_id){b._session_id=a[1];b._wamp_version=a[2];b._server=a[3];if(ab._debugrpc||ab._debugpubsub)console.group("WAMP Welcome"),console.info(b._wsuri+"  ["+b._session_id+"]"),console.log(b._wamp_version),console.log(b._server),console.groupEnd();null!==b._websocket_onopen&&b._websocket_onopen()}else throw"protocol error (welcome message received more than once)";};b._websocket.onopen=function(){if(b._websocket.protocol!==ab._subprotocol)if("undefined"===typeof b._websocket.protocol)ab._debugws&&
(console.group("WS Warning"),console.info(b._wsuri),console.log("WebSocket object has no protocol attribute: WAMP subprotocol check skipped!"),console.groupEnd());else if(b._options&&b._options.skipSubprotocolCheck)ab._debugws&&(console.group("WS Warning"),console.info(b._wsuri),console.log("Server does not speak WAMP, but subprotocol check disabled by option!"),console.log(b._websocket.protocol),console.groupEnd());else throw b._websocket.close(1E3,"server does not speak WAMP"),"server does not speak WAMP (but '"+
b._websocket.protocol+"' !)";ab._debugws&&(console.group("WAMP Connect"),console.info(b._wsuri),console.log(b._websocket.protocol),console.groupEnd());b._websocket_connected=!0};b._websocket.onerror=function(){};b._websocket.onclose=function(a){ab._debugws&&(b._websocket_connected?console.log("Autobahn connection to "+b._wsuri+" lost (code "+a.code+", reason '"+a.reason+"', wasClean "+a.wasClean+")."):console.log("Autobahn could not connect to "+b._wsuri+" (code "+a.code+", reason '"+a.reason+"', wasClean "+
a.wasClean+")."));void 0!==b._websocket_onclose&&(b._websocket_connected?a.wasClean?b._websocket_onclose(ab.CONNECTION_CLOSED):b._websocket_onclose(ab.CONNECTION_LOST):b._websocket_onclose(ab.CONNECTION_UNREACHABLE));b._websocket_connected=!1;b._wsuri=null;b._websocket_onopen=null;b._websocket_onclose=null;b._websocket=null}};
ab.Session.prototype._send=function(a){if(!this._websocket_connected)throw"Autobahn not connected";a=JSON.stringify(a);this._websocket.send(a);this._txcnt+=1;ab._debugws&&(console.group("WS Send"),console.info(this._wsuri+"  ["+this._session_id+"]"),console.log(this._txcnt),console.log(a),console.groupEnd())};ab.Session.prototype.close=function(){this._websocket_connected&&this._websocket.close()};ab.Session.prototype.sessionid=function(){return this._session_id};
ab.Session.prototype.shrink=function(a,c){void 0===c&&(c=!0);return this._prefixes.shrink(a,c)};ab.Session.prototype.resolve=function(a,c){void 0===c&&(c=!0);return this._prefixes.resolve(a,c)};ab.Session.prototype.prefix=function(a,c){this._prefixes.set(a,c);if(ab._debugrpc||ab._debugpubsub)console.group("WAMP Prefix"),console.info(this._wsuri+"  ["+this._session_id+"]"),console.log(a),console.log(c),console.groupEnd();this._send([ab._MESSAGE_TYPEID_PREFIX,a,c])};
ab.Session.prototype.call=function(){for(var a=new ab._Deferred,c;!(c=ab._newid(),!(c in this._calls)););this._calls[c]=a;for(var e=this._prefixes.shrink(arguments[0],!0),e=[ab._MESSAGE_TYPEID_CALL,c,e],d=1;d<arguments.length;d+=1)e.push(arguments[d]);this._send(e);ab._debugrpc&&(a._ab_callobj=e,a._ab_tid=this._wsuri+"  ["+this._session_id+"]["+c+"]",console.time(a._ab_tid),console.info());return a};
ab.Session.prototype.subscribe=function(a,c){var e=this._prefixes.resolve(a,!0);e in this._subscriptions||(ab._debugpubsub&&(console.group("WAMP Subscribe"),console.info(this._wsuri+"  ["+this._session_id+"]"),console.log(a),console.log(c),console.groupEnd()),this._send([ab._MESSAGE_TYPEID_SUBSCRIBE,a]),this._subscriptions[e]=[]);if(-1===this._subscriptions[e].indexOf(c))this._subscriptions[e].push(c);else throw"callback "+c+" already subscribed for topic "+e;};
ab.Session.prototype.unsubscribe=function(a,c){var e=this._prefixes.resolve(a,!0);if(e in this._subscriptions){var d;if(void 0!==c){var b=this._subscriptions[e].indexOf(c);if(-1!==b)d=c,this._subscriptions[e].splice(b,1);else throw"no callback "+c+" subscribed on topic "+e;}else d=this._subscriptions[e].slice(),this._subscriptions[e]=[];0===this._subscriptions[e].length&&(delete this._subscriptions[e],ab._debugpubsub&&(console.group("WAMP Unsubscribe"),console.info(this._wsuri+"  ["+this._session_id+
"]"),console.log(a),console.log(d),console.groupEnd()),this._send([ab._MESSAGE_TYPEID_UNSUBSCRIBE,a]))}else throw"not subscribed to topic "+e;};
ab.Session.prototype.publish=function(){var a=arguments[0],c=arguments[1],e=null,d=null,b=null,f=null;if(3<arguments.length){if(!(arguments[2]instanceof Array))throw"invalid argument type(s)";if(!(arguments[3]instanceof Array))throw"invalid argument type(s)";d=arguments[2];b=arguments[3];f=[ab._MESSAGE_TYPEID_PUBLISH,a,c,d,b]}else if(2<arguments.length)if("boolean"===typeof arguments[2])e=arguments[2],f=[ab._MESSAGE_TYPEID_PUBLISH,a,c,e];else if(arguments[2]instanceof Array)d=arguments[2],f=[ab._MESSAGE_TYPEID_PUBLISH,
a,c,d];else throw"invalid argument type(s)";else f=[ab._MESSAGE_TYPEID_PUBLISH,a,c];ab._debugpubsub&&(console.group("WAMP Publish"),console.info(this._wsuri+"  ["+this._session_id+"]"),console.log(a),console.log(c),null!==e?console.log(e):null!==d&&(console.log(d),null!==b&&console.log(b)),console.groupEnd());this._send(f)};ab.Session.prototype.authreq=function(a,c){return this.call("http://api.wamp.ws/procedure#authreq",a,c)};
ab.Session.prototype.authsign=function(a,c){c||(c="");return Crypto.util.bytesToBase64(Crypto.HMAC(Crypto.SHA256,a,c,{asBytes:!0}))};ab.Session.prototype.auth=function(a){return this.call("http://api.wamp.ws/procedure#auth",a)};
ab._connect=function(a){var c=new ab.Session(a.wsuri,function(){a.connects+=1;a.retryCount=0;a.onConnect(c)},function(c){switch(c){case ab.CONNECTION_CLOSED:a.onHangup(c,"Connection was closed properly - done.");break;case ab.CONNECTION_UNSUPPORTED:a.onHangup(c,"Browser does not support WebSocket.");break;case ab.CONNECTION_UNREACHABLE:a.retryCount+=1;if(0==a.connects)a.onHangup(c,"Connection could not be established.");else if(a.retryCount<=a.options.maxRetries)(c=a.onHangup(ab.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT,
"Connection unreachable - scheduled reconnect to occur in "+a.options.retryDelay/1E3+" second(s).",{delay:a.options.retryDelay,retries:a.retryCount,maxretries:a.options.maxRetries}))?(console.log("Connection unreachable - retrying stopped by app"),a.onHangup(ab.CONNECTION_RETRIES_EXCEEDED,"Number of connection retries exceeded.")):(console.log("Connection unreachable - retrying ("+a.retryCount+") .."),window.setTimeout(ab._connect,a.options.retryDelay,a));else a.onHangup(ab.CONNECTION_RETRIES_EXCEEDED,
"Number of connection retries exceeded.");break;case ab.CONNECTION_LOST:a.retryCount+=1;if(a.retryCount<=a.options.maxRetries)(c=a.onHangup(ab.CONNECTION_LOST_SCHEDULED_RECONNECT,"Connection lost - scheduled reconnect to occur in "+a.options.retryDelay/1E3+" second(s).",{delay:a.options.retryDelay,retries:a.retryCount,maxretries:a.options.maxRetries}))?(console.log("Connection lost - retrying stopped by app"),a.onHangup(ab.CONNECTION_RETRIES_EXCEEDED,"Connection lost.")):(console.log("Connection lost - retrying ("+
a.retryCount+") .."),window.setTimeout(ab._connect,a.options.retryDelay,a));else a.onHangup(ab.CONNECTION_RETRIES_EXCEEDED,"Connection lost.");break;default:throw"unhandled close code in ab._connect";}},a.options)};
ab.connect=function(a,c,e,d){peer={};peer.wsuri=a;peer.options=d?d:{};void 0==peer.options.retryDelay&&(peer.options.retryDelay=5E3);void 0==peer.options.maxRetries&&(peer.options.maxRetries=10);void 0==peer.options.skipSubprotocolCheck&&(peer.options.skipSubprotocolCheck=!1);if(c)peer.onConnect=c;else throw"onConnect handler required!";peer.onHangup=e?e:function(a,c){console.log(c)};peer.connects=0;peer.retryCount=0;ab._connect(peer)};ab._UA_FIREFOX=/.*Firefox\/([0-9+]*).*/;ab._UA_CHROME=/.*Chrome\/([0-9+]*).*/;ab._UA_CHROMEFRAME=/.*chromeframe\/([0-9]*).*/;ab._UA_WEBKIT=/.*AppleWebKit\/([0-9+.]*)w*.*/;ab._UA_WEBOS=/.*webOS\/([0-9+.]*)w*.*/;ab._matchRegex=function(a,c){var e=c.exec(a);return e?e[1]:e};
ab.lookupWsSupport=function(){var a=navigator.userAgent;if(-1<a.indexOf("MSIE")){if(-1<a.indexOf("MSIE 10"))return[!0,!0,!0];if(-1<a.indexOf("chromeframe")){var c=parseInt(ab._matchRegex(a,ab._UA_CHROMEFRAME));return 14<=c?[!0,!1,!0]:[!1,!1,!1]}if(-1<a.indexOf("MSIE 8")||-1<a.indexOf("MSIE 9"))return[!0,!0,!0]}else{if(-1<a.indexOf("Firefox")){if(c=parseInt(ab._matchRegex(a,ab._UA_FIREFOX))){if(7<=c)return[!0,!1,!0];if(3<=c)return[!0,!0,!0]}return[!1,!1,!0]}if(-1<a.indexOf("Safari")&&-1==a.indexOf("Chrome")){if(c=
ab._matchRegex(a,ab._UA_WEBKIT))return-1<a.indexOf("Windows")&&"534+"==c||-1<a.indexOf("Macintosh")&&(c=c.replace("+","").split("."),535==parseInt(c[0])&&24<=parseInt(c[1])||535<parseInt(c[0]))?[!0,!1,!0]:-1<a.indexOf("webOS")?(c=ab._matchRegex(a,ab._UA_WEBOS).split("."),2==parseInt(c[0])?[!1,!0,!0]:[!1,!1,!1]):[!0,!0,!0]}else if(-1<a.indexOf("Chrome")){if(c=parseInt(ab._matchRegex(a,ab._UA_CHROME)))return 14<=c?[!0,!1,!0]:4<=c?[!0,!0,!0]:[!1,!1,!0]}else if(-1<a.indexOf("Android")){if(-1<a.indexOf("Firefox")||
-1<a.indexOf("CrMo"))return[!0,!1,!0];if(-1<a.indexOf("Opera"))return[!1,!1,!0];if(-1<a.indexOf("CrMo"))return[!0,!0,!0]}else if(-1<a.indexOf("iPhone")||-1<a.indexOf("iPad")||-1<a.indexOf("iPod"))return[!1,!1,!0]}return[!1,!1,!1]};
     </script>

      <script>

// MIT License:
//
// Copyright (c) 2010-2013, Joe Walnes
//               2013-2014, Drew Noakes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Smoothie Charts - http://smoothiecharts.org/
 * (c) 2010-2013, Joe Walnes
 *     2013-2014, Drew Noakes
 *
 * v1.0: Main charting library, by Joe Walnes
 * v1.1: Auto scaling of axis, by Neil Dunn
 * v1.2: fps (frames per second) option, by Mathias Petterson
 * v1.3: Fix for divide by zero, by Paul Nikitochkin
 * v1.4: Set minimum, top-scale padding, remove timeseries, add optional timer to reset bounds, by Kelley Reynolds
 * v1.5: Set default frames per second to 50... smoother.
 *       .start(), .stop() methods for conserving CPU, by Dmitry Vyal
 *       options.interpolation = 'bezier' or 'line', by Dmitry Vyal
 *       options.maxValue to fix scale, by Dmitry Vyal
 * v1.6: minValue/maxValue will always get converted to floats, by Przemek Matylla
 * v1.7: options.grid.fillStyle may be a transparent color, by Dmitry A. Shashkin
 *       Smooth rescaling, by Kostas Michalopoulos
 * v1.8: Set max length to customize number of live points in the dataset with options.maxDataSetLength, by Krishna Narni
 * v1.9: Display timestamps along the bottom, by Nick and Stev-io
 *       (https://groups.google.com/forum/?fromgroups#!topic/smoothie-charts/-Ywse8FCpKI%5B1-25%5D)
 *       Refactored by Krishna Narni, to support timestamp formatting function
 * v1.10: Switch to requestAnimationFrame, removed the now obsoleted options.fps, by Gergely Imreh
 * v1.11: options.grid.sharpLines option added, by @drewnoakes
 *        Addressed warning seen in Firefox when seriesOption.fillStyle undefined, by @drewnoakes
 * v1.12: Support for horizontalLines added, by @drewnoakes
 *        Support for yRangeFunction callback added, by @drewnoakes
 * v1.13: Fixed typo (#32), by @alnikitich
 * v1.14: Timer cleared when last TimeSeries removed (#23), by @davidgaleano
 *        Fixed diagonal line on chart at start/end of data stream, by @drewnoakes
 * v1.15: Support for npm package (#18), by @dominictarr
 *        Fixed broken removeTimeSeries function (#24) by @davidgaleano
 *        Minor performance and tidying, by @drewnoakes
 * v1.16: Bug fix introduced in v1.14 relating to timer creation/clearance (#23), by @drewnoakes
 *        TimeSeries.append now deals with out-of-order timestamps, and can merge duplicates, by @zacwitte (#12)
 *        Documentation and some local variable renaming for clarity, by @drewnoakes
 * v1.17: Allow control over font size (#10), by @drewnoakes
 *        Timestamp text won't overlap, by @drewnoakes
 * v1.18: Allow control of max/min label precision, by @drewnoakes
 *        Added 'borderVisible' chart option, by @drewnoakes
 *        Allow drawing series with fill but no stroke (line), by @drewnoakes
 * v1.19: Avoid unnecessary repaints, and fixed flicker in old browsers having multiple charts in document (#40), by @asbai
 * v1.20: Add SmoothieChart.getTimeSeriesOptions and SmoothieChart.bringToFront functions, by @drewnoakes
 * v1.21: Add 'step' interpolation mode, by @drewnoakes
 */

;(function(exports) {

  var Util = {
    extend: function() {
      arguments[0] = arguments[0] || {};
      for (var i = 1; i < arguments.length; i++)
      {
        for (var key in arguments[i])
        {
          if (arguments[i].hasOwnProperty(key))
          {
            if (typeof(arguments[i][key]) === 'object') {
              if (arguments[i][key] instanceof Array) {
                arguments[0][key] = arguments[i][key];
              } else {
                arguments[0][key] = Util.extend(arguments[0][key], arguments[i][key]);
              }
            } else {
              arguments[0][key] = arguments[i][key];
            }
          }
        }
      }
      return arguments[0];
    }
  };

  /**
   * Initialises a new <code>TimeSeries</code> with optional data options.
   *
   * Options are of the form (defaults shown):
   *
   * <pre>
   * {
   *   resetBounds: true,        // enables/disables automatic scaling of the y-axis
   *   resetBoundsInterval: 3000 // the period between scaling calculations, in millis
   * }
   * </pre>
   *
   * Presentation options for TimeSeries are specified as an argument to <code>SmoothieChart.addTimeSeries</code>.
   *
   * @constructor
   */
  function TimeSeries(options) {
    this.options = Util.extend({}, TimeSeries.defaultOptions, options);
    this.data = [];
    this.maxValue = Number.NaN; // The maximum value ever seen in this TimeSeries.
    this.minValue = Number.NaN; // The minimum value ever seen in this TimeSeries.
  }

  TimeSeries.defaultOptions = {
    resetBoundsInterval: 3000,
    resetBounds: true
  };

  /**
   * Recalculate the min/max values for this <code>TimeSeries</code> object.
   *
   * This causes the graph to scale itself in the y-axis.
   */
  TimeSeries.prototype.resetBounds = function() {
    if (this.data.length) {
      // Walk through all data points, finding the min/max value
      this.maxValue = this.data[0][1];
      this.minValue = this.data[0][1];
      for (var i = 1; i < this.data.length; i++) {
        var value = this.data[i][1];
        if (value > this.maxValue) {
          this.maxValue = value;
        }
        if (value < this.minValue) {
          this.minValue = value;
        }
      }
    } else {
      // No data exists, so set min/max to NaN
      this.maxValue = Number.NaN;
      this.minValue = Number.NaN;
    }
  };

  /**
   * Adds a new data point to the <code>TimeSeries</code>, preserving chronological order.
   *
   * @param timestamp the position, in time, of this data point
   * @param value the value of this data point
   * @param sumRepeatedTimeStampValues if <code>timestamp</code> has an exact match in the series, this flag controls
   * whether it is replaced, or the values summed (defaults to false.)
   */
  TimeSeries.prototype.append = function(timestamp, value, sumRepeatedTimeStampValues) {
    // Rewind until we hit an older timestamp
    var i = this.data.length - 1;
    while (i > 0 && this.data[i][0] > timestamp) {
      i--;
    }

    if (this.data.length > 0 && this.data[i][0] === timestamp) {
      // Update existing values in the array
      if (sumRepeatedTimeStampValues) {
        // Sum this value into the existing 'bucket'
        this.data[i][1] += value;
        value = this.data[i][1];
      } else {
        // Replace the previous value
        this.data[i][1] = value;
      }
    } else if (i < this.data.length - 1) {
      // Splice into the correct position to keep timestamps in order
      this.data.splice(i + 1, 0, [timestamp, value]);
    } else {
      // Add to the end of the array
      this.data.push([timestamp, value]);
    }

    this.maxValue = isNaN(this.maxValue) ? value : Math.max(this.maxValue, value);
    this.minValue = isNaN(this.minValue) ? value : Math.min(this.minValue, value);
  };

  TimeSeries.prototype.dropOldData = function(oldestValidTime, maxDataSetLength) {
    // We must always keep one expired data point as we need this to draw the
    // line that comes into the chart from the left, but any points prior to that can be removed.
    var removeCount = 0;
    while (this.data.length - removeCount >= maxDataSetLength && this.data[removeCount + 1][0] < oldestValidTime) {
      removeCount++;
    }
    if (removeCount !== 0) {
      this.data.splice(0, removeCount);
    }
  };

  /**
   * Initialises a new <code>SmoothieChart</code>.
   *
   * Options are optional, and should be of the form below. Just specify the values you
   * need and the rest will be given sensible defaults as shown:
   *
   * <pre>
   * {
   *   minValue: undefined,        // specify to clamp the lower y-axis to a given value
   *   maxValue: undefined,        // specify to clamp the upper y-axis to a given value
   *   maxValueScale: 1,           // allows proportional padding to be added above the chart. for 10% padding, specify 1.1.
   *   yRangeFunction: undefined,  // function({min: , max: }) { return {min: , max: }; }
   *   scaleSmoothing: 0.125,      // controls the rate at which y-value zoom animation occurs
   *   millisPerPixel: 20,         // sets the speed at which the chart pans by
   *   maxDataSetLength: 2,
   *   interpolation: 'bezier'     // one of 'bezier', 'linear', or 'step'
   *   timestampFormatter: null,   // Optional function to format time stamps for bottom of chart. You may use SmoothieChart.timeFormatter, or your own: function(date) { return ''; }
   *   horizontalLines: [],        // [ { value: 0, color: '#ffffff', lineWidth: 1 } ],
   *   grid:
   *   {
   *     fillStyle: '#000000',     // the background colour of the chart
   *     lineWidth: 1,             // the pixel width of grid lines
   *     strokeStyle: '#777777',   // colour of grid lines
   *     millisPerLine: 1000,      // distance between vertical grid lines
   *     sharpLines: false,        // controls whether grid lines are 1px sharp, or softened
   *     verticalSections: 2,      // number of vertical sections marked out by horizontal grid lines
   *     borderVisible: true       // whether the grid lines trace the border of the chart or not
   *   },
   *   labels
   *   {
   *     disabled: false,          // enables/disables labels showing the min/max values
   *     fillStyle: '#ffffff',     // colour for text of labels,
   *     fontSize: 15,
   *     fontFamily: 'sans-serif',
   *     precision: 2
   *   },
   * }
   * </pre>
   *
   * @constructor
   */
  function SmoothieChart(options) {
    this.options = Util.extend({}, SmoothieChart.defaultChartOptions, options);
    this.seriesSet = [];
    this.currentValueRange = 1;
    this.currentVisMinValue = 0;
    this.lastRenderTimeMillis = 0;
  }

  SmoothieChart.defaultChartOptions = {
    millisPerPixel: 20,
    maxValueScale: 1,
    interpolation: 'bezier',
    scaleSmoothing: 0.125,
    maxDataSetLength: 2,
    grid: {
      fillStyle: '#000000',
      strokeStyle: '#777777',
      lineWidth: 1,
      sharpLines: false,
      millisPerLine: 1000,
      verticalSections: 2,
      borderVisible: true
    },
    labels: {
      fillStyle: '#ffffff',
      disabled: false,
      fontSize: 10,
      fontFamily: 'monospace',
      precision: 2
    },
    horizontalLines: []
  };

  // Based on http://inspirit.github.com/jsfeat/js/compatibility.js
  SmoothieChart.AnimateCompatibility = (function() {
    var requestAnimationFrame = function(callback, element) {
          var requestAnimationFrame =
            window.requestAnimationFrame        ||
            window.webkitRequestAnimationFrame  ||
            window.mozRequestAnimationFrame     ||
            window.oRequestAnimationFrame       ||
            window.msRequestAnimationFrame      ||
            function(callback) {
              return window.setTimeout(function() {
                callback(new Date().getTime());
              }, 16);
            };
          return requestAnimationFrame.call(window, callback, element);
        },
        cancelAnimationFrame = function(id) {
          var cancelAnimationFrame =
            window.cancelAnimationFrame ||
            function(id) {
              clearTimeout(id);
            };
          return cancelAnimationFrame.call(window, id);
        };

    return {
      requestAnimationFrame: requestAnimationFrame,
      cancelAnimationFrame: cancelAnimationFrame
    };
  })();

  SmoothieChart.defaultSeriesPresentationOptions = {
    lineWidth: 1,
    strokeStyle: '#ffffff'
  };

  /**
   * Adds a <code>TimeSeries</code> to this chart, with optional presentation options.
   *
   * Presentation options should be of the form (defaults shown):
   *
   * <pre>
   * {
   *   lineWidth: 1,
   *   strokeStyle: '#ffffff',
   *   fillStyle: undefined
   * }
   * </pre>
   */
  SmoothieChart.prototype.addTimeSeries = function(timeSeries, options) {
    this.seriesSet.push({timeSeries: timeSeries, options: Util.extend({}, SmoothieChart.defaultSeriesPresentationOptions, options)});
    if (timeSeries.options.resetBounds && timeSeries.options.resetBoundsInterval > 0) {
      timeSeries.resetBoundsTimerId = setInterval(
        function() {
          timeSeries.resetBounds();
        },
        timeSeries.options.resetBoundsInterval
      );
    }
  };

  /**
   * Removes the specified <code>TimeSeries</code> from the chart.
   */
  SmoothieChart.prototype.removeTimeSeries = function(timeSeries) {
    // Find the correct timeseries to remove, and remove it
    var numSeries = this.seriesSet.length;
    for (var i = 0; i < numSeries; i++) {
      if (this.seriesSet[i].timeSeries === timeSeries) {
        this.seriesSet.splice(i, 1);
        break;
      }
    }
    // If a timer was operating for that timeseries, remove it
    if (timeSeries.resetBoundsTimerId) {
      // Stop resetting the bounds, if we were
      clearInterval(timeSeries.resetBoundsTimerId);
    }
  };

  /**
   * Gets render options for the specified <code>TimeSeries</code>.
   *
   * As you may use a single <code>TimeSeries</code> in multiple charts with different formatting in each usage,
   * these settings are stored in the chart.
   */
  SmoothieChart.prototype.getTimeSeriesOptions = function(timeSeries) {
    // Find the correct timeseries to remove, and remove it
    var numSeries = this.seriesSet.length;
    for (var i = 0; i < numSeries; i++) {
      if (this.seriesSet[i].timeSeries === timeSeries) {
        return this.seriesSet[i].options;
      }
    }
  };

  /**
   * Brings the specified <code>TimeSeries</code> to the top of the chart. It will be rendered last.
   */
  SmoothieChart.prototype.bringToFront = function(timeSeries) {
    // Find the correct timeseries to remove, and remove it
    var numSeries = this.seriesSet.length;
    for (var i = 0; i < numSeries; i++) {
      if (this.seriesSet[i].timeSeries === timeSeries) {
        var set = this.seriesSet.splice(i, 1);
        this.seriesSet.push(set[0]);
        break;
      }
    }
  };

  /**
   * Instructs the <code>SmoothieChart</code> to start rendering to the provided canvas, with specified delay.
   *
   * @param canvas the target canvas element
   * @param delayMillis an amount of time to wait before a data point is shown. This can prevent the end of the series
   * from appearing on screen, with new values flashing into view, at the expense of some latency.
   */
  SmoothieChart.prototype.streamTo = function(canvas, delayMillis) {
    this.canvas = canvas;
    this.delay = delayMillis;
    this.start();
  };

  /**
   * Starts the animation of this chart.
   */
  SmoothieChart.prototype.start = function() {
    if (this.frame) {
      // We're already running, so just return
      return;
    }

    // Renders a frame, and queues the next frame for later rendering
    var animate = function() {
      this.frame = SmoothieChart.AnimateCompatibility.requestAnimationFrame(function() {
        this.render();
        animate();
      }.bind(this));
    }.bind(this);

    animate();
  };

  /**
   * Stops the animation of this chart.
   */
  SmoothieChart.prototype.stop = function() {
    if (this.frame) {
      SmoothieChart.AnimateCompatibility.cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  };

  SmoothieChart.prototype.updateValueRange = function() {
    // Calculate the current scale of the chart, from all time series.
    var chartOptions = this.options,
        chartMaxValue = Number.NaN,
        chartMinValue = Number.NaN;

    for (var d = 0; d < this.seriesSet.length; d++) {
      // TODO(ndunn): We could calculate / track these values as they stream in.
      var timeSeries = this.seriesSet[d].timeSeries;
      if (!isNaN(timeSeries.maxValue)) {
        chartMaxValue = !isNaN(chartMaxValue) ? Math.max(chartMaxValue, timeSeries.maxValue) : timeSeries.maxValue;
      }

      if (!isNaN(timeSeries.minValue)) {
        chartMinValue = !isNaN(chartMinValue) ? Math.min(chartMinValue, timeSeries.minValue) : timeSeries.minValue;
      }
    }

    // Scale the chartMaxValue to add padding at the top if required
    if (chartOptions.maxValue != null) {
      chartMaxValue = chartOptions.maxValue;
    } else {
      chartMaxValue *= chartOptions.maxValueScale;
    }

    // Set the minimum if we've specified one
    if (chartOptions.minValue != null) {
      chartMinValue = chartOptions.minValue;
    }

    // If a custom range function is set, call it
    if (this.options.yRangeFunction) {
      var range = this.options.yRangeFunction({min: chartMinValue, max: chartMaxValue});
      chartMinValue = range.min;
      chartMaxValue = range.max;
    }

    if (!isNaN(chartMaxValue) && !isNaN(chartMinValue)) {
      var targetValueRange = chartMaxValue - chartMinValue;
      var valueRangeDiff = (targetValueRange - this.currentValueRange);
      var minValueDiff = (chartMinValue - this.currentVisMinValue);
      this.isAnimatingScale = Math.abs(valueRangeDiff) > 0.1 || Math.abs(minValueDiff) > 0.1;
      this.currentValueRange += chartOptions.scaleSmoothing * valueRangeDiff;
      this.currentVisMinValue += chartOptions.scaleSmoothing * minValueDiff;
    }

    this.valueRange = { min: chartMinValue, max: chartMaxValue };
  };

  SmoothieChart.prototype.render = function(canvas, time) {
    var nowMillis = new Date().getTime();

    if (!this.isAnimatingScale) {
      // We're not animating. We can use the last render time and the scroll speed to work out whether
      // we actually need to paint anything yet. If not, we can return immediately.

      // Render at least every 1/6th of a second. The canvas may be resized, which there is
      // no reliable way to detect.
      var maxIdleMillis = Math.min(1000/6, this.options.millisPerPixel);

      if (nowMillis - this.lastRenderTimeMillis < maxIdleMillis) {
        return;
      }
    }
    this.lastRenderTimeMillis = nowMillis;
    
    canvas = canvas || this.canvas;
    time = time || nowMillis - (this.delay || 0);

    // Round time down to pixel granularity, so motion appears smoother.
    time -= time % this.options.millisPerPixel;

    var context = canvas.getContext('2d'),
        chartOptions = this.options,
        dimensions = { top: 0, left: 0, width: canvas.clientWidth, height: canvas.clientHeight },
        // Calculate the threshold time for the oldest data points.
        oldestValidTime = time - (dimensions.width * chartOptions.millisPerPixel),
        valueToYPixel = function(value) {
          var offset = value - this.currentVisMinValue;
          return this.currentValueRange === 0
            ? dimensions.height
            : dimensions.height - (Math.round((offset / this.currentValueRange) * dimensions.height));
        }.bind(this),
        timeToXPixel = function(t) {
          return Math.round(dimensions.width - ((time - t) / chartOptions.millisPerPixel));
        };

    this.updateValueRange();

    context.font = chartOptions.labels.fontSize + 'px ' + chartOptions.labels.fontFamily;

    // Save the state of the canvas context, any transformations applied in this method
    // will get removed from the stack at the end of this method when .restore() is called.
    context.save();

    // Move the origin.
    context.translate(dimensions.left, dimensions.top);

    // Create a clipped rectangle - anything we draw will be constrained to this rectangle.
    // This prevents the occasional pixels from curves near the edges overrunning and creating
    // screen cheese (that phrase should need no explanation).
    context.beginPath();
    context.rect(0, 0, dimensions.width, dimensions.height);
    context.clip();

    // Clear the working area.
    context.save();
    context.fillStyle = chartOptions.grid.fillStyle;
    context.clearRect(0, 0, dimensions.width, dimensions.height);
    context.fillRect(0, 0, dimensions.width, dimensions.height);
    context.restore();

    // Grid lines...
    context.save();
    context.lineWidth = chartOptions.grid.lineWidth;
    context.strokeStyle = chartOptions.grid.strokeStyle;
    // Vertical (time) dividers.
    if (chartOptions.grid.millisPerLine > 0) {
      var textUntilX = dimensions.width - context.measureText(minValueString).width + 4;
      for (var t = time - (time % chartOptions.grid.millisPerLine);
           t >= oldestValidTime;
           t -= chartOptions.grid.millisPerLine) {
        var gx = timeToXPixel(t);
        if (chartOptions.grid.sharpLines) {
          gx -= 0.5;
        }
        context.beginPath();
        context.moveTo(gx, 0);
        context.lineTo(gx, dimensions.height);
        context.stroke();
        context.closePath();

        // Display timestamp at bottom of this line if requested, and it won't overlap
        if (chartOptions.timestampFormatter && gx < textUntilX) {
          // Formats the timestamp based on user specified formatting function
          // SmoothieChart.timeFormatter function above is one such formatting option
          var tx = new Date(t),
            ts = chartOptions.timestampFormatter(tx),
            tsWidth = context.measureText(ts).width;
          textUntilX = gx - tsWidth - 2;
          context.fillStyle = chartOptions.labels.fillStyle;
          context.fillText(ts, gx - tsWidth, dimensions.height - 2);
        }
      }
    }

    // Horizontal (value) dividers.
    for (var v = 1; v < chartOptions.grid.verticalSections; v++) {
      var gy = Math.round(v * dimensions.height / chartOptions.grid.verticalSections);
      if (chartOptions.grid.sharpLines) {
        gy -= 0.5;
      }
      context.beginPath();
      context.moveTo(0, gy);
      context.lineTo(dimensions.width, gy);
      context.stroke();
      context.closePath();
    }
    // Bounding rectangle.
    if (chartOptions.grid.borderVisible) {
      context.beginPath();
      context.strokeRect(0, 0, dimensions.width, dimensions.height);
      context.closePath();
    }
    context.restore();

    // Draw any horizontal lines...
    if (chartOptions.horizontalLines && chartOptions.horizontalLines.length) {
      for (var hl = 0; hl < chartOptions.horizontalLines.length; hl++) {
        var line = chartOptions.horizontalLines[hl],
            hly = Math.round(valueToYPixel(line.value)) - 0.5;
        context.strokeStyle = line.color || '#ffffff';
        context.lineWidth = line.lineWidth || 1;
        context.beginPath();
        context.moveTo(0, hly);
        context.lineTo(dimensions.width, hly);
        context.stroke();
        context.closePath();
      }
    }

    // For each data set...
    for (var d = 0; d < this.seriesSet.length; d++) {
      context.save();
      var timeSeries = this.seriesSet[d].timeSeries,
          dataSet = timeSeries.data,
          seriesOptions = this.seriesSet[d].options;

      // Delete old data that's moved off the left of the chart.
      timeSeries.dropOldData(oldestValidTime, chartOptions.maxDataSetLength);

      // Set style for this dataSet.
      context.lineWidth = seriesOptions.lineWidth;
      context.strokeStyle = seriesOptions.strokeStyle;
      // Draw the line...
      context.beginPath();
      // Retain lastX, lastY for calculating the control points of bezier curves.
      var firstX = 0, lastX = 0, lastY = 0;
      for (var i = 0; i < dataSet.length && dataSet.length !== 1; i++) {
        var x = timeToXPixel(dataSet[i][0]),
            y = valueToYPixel(dataSet[i][1]);

        if (i === 0) {
          firstX = x;
          context.moveTo(x, y);
        } else {
          switch (chartOptions.interpolation) {
            case "linear":
            case "line": {
              context.lineTo(x,y);
              break;
            }
            case "bezier":
            default: {
              // Great explanation of Bezier curves: http://en.wikipedia.org/wiki/Bezier_curve#Quadratic_curves
              //
              // Assuming A was the last point in the line plotted and B is the new point,
              // we draw a curve with control points P and Q as below.
              //
              // A---P
              //     |
              //     |
              //     |
              //     Q---B
              //
              // Importantly, A and P are at the same y coordinate, as are B and Q. This is
              // so adjacent curves appear to flow as one.
              //
              context.bezierCurveTo( // startPoint (A) is implicit from last iteration of loop
                Math.round((lastX + x) / 2), lastY, // controlPoint1 (P)
                Math.round((lastX + x)) / 2, y, // controlPoint2 (Q)
                x, y); // endPoint (B)
              break;
            }
            case "step": {
              context.lineTo(x,lastY);
              context.lineTo(x,y);
              break;
            }
          }
        }

        lastX = x; lastY = y;
      }

      if (dataSet.length > 1) {
        if (seriesOptions.fillStyle) {
          // Close up the fill region.
          context.lineTo(dimensions.width + seriesOptions.lineWidth + 1, lastY);
          context.lineTo(dimensions.width + seriesOptions.lineWidth + 1, dimensions.height + seriesOptions.lineWidth + 1);
          context.lineTo(firstX, dimensions.height + seriesOptions.lineWidth);
          context.fillStyle = seriesOptions.fillStyle;
          context.fill();
        }

        if (seriesOptions.strokeStyle && seriesOptions.strokeStyle !== 'none') {
          context.stroke();
        }
        context.closePath();
      }
      context.restore();
    }

    // Draw the axis values on the chart.
    if (!chartOptions.labels.disabled && !isNaN(this.valueRange.min) && !isNaN(this.valueRange.max)) {
      var maxValueString = parseFloat(this.valueRange.max).toFixed(chartOptions.labels.precision),
          minValueString = parseFloat(this.valueRange.min).toFixed(chartOptions.labels.precision);
      context.fillStyle = chartOptions.labels.fillStyle;
      context.fillText(maxValueString, dimensions.width - context.measureText(maxValueString).width - 2, chartOptions.labels.fontSize);
      context.fillText(minValueString, dimensions.width - context.measureText(minValueString).width - 2, dimensions.height - 2);
    }

    context.restore(); // See .save() above.
  };

  // Sample timestamp formatting function
  SmoothieChart.timeFormatter = function(date) {
    function pad2(number) { return (number < 10 ? '0' : '') + number }
    return pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds());
  };

  exports.TimeSeries = TimeSeries;
  exports.SmoothieChart = SmoothieChart;

})(typeof exports === 'undefined' ? this : exports);

      </script>

      <script>
         function getClientname(str) {
            var re = str.split("/");
            return re[3];
            }

         function getSensorname(str) {
            var re = str.split("/");
            return re[4].split("#")[1].split("-")[0];
            }

         function onOwValue(topicUri, event) {
            client = getClientname(topicUri)
            inst = getSensorname(topicUri)
            eval("eventcnt_"+client+"_"+inst+" += 1;");             
            event.value = event.value;
            switch (event.id) {
               case 5:
                  event.value = event.value.toFixed(2);
                  eval("t_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = t_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_t_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("t_"+client+"_"+inst+"_last = event.value;");
                  eval("line_t_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 0:
                  eval("time_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 7:
                  eval("rh_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 12:
                  eval("vdd_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 13:
                  eval("vad_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 14:
                  eval("vis_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 10:
                  hostname.innerHTML = event.value;
                  break;
                default:
                  break;
            }
         }

         function onCsValue(topicUri, event) {
            client = getClientname(topicUri);
            inst = getSensorname(topicUri);
            eval("eventcnt_"+client+"_"+inst+" += 1;");             
            event.value = event.value;
            switch (event.id) {
               case 4:
                  event.value = event.value.toFixed(2);
                  eval("f_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = f_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_f_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("f_"+client+"_"+inst+"_last = event.value;");
                  eval("line_f_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 0:
                  eval("time_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               default:
                  break;
            }
         }

         function onEnvValue(topicUri, event) {
            client = getClientname(topicUri)
            inst = getSensorname(topicUri)
            eval("eventcnt_"+client+"_"+inst+" += 1;");             
            event.value = event.value;
            switch (event.id) {
               case 0:
                  eval("time_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 7:
                  event.value = event.value.toFixed(2);
                  eval("vara_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = vara_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_vara_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("vara_"+client+"_"+inst+"_last = event.value;");
                  eval("line_vara_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 5:
                  event.value = event.value.toFixed(2);
                  eval("ta_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = ta_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_ta_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("ta_"+client+"_"+inst+"_last = event.value;");
                  eval("line_ta_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 6:
                  event.value = event.value.toFixed(2);
                  eval("tb_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = tb_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_tb_"+".append(new Date().getTime(), lastval);");
                  }
                  eval("tb_"+client+"_"+inst+"_last = event.value;");
                  eval("line_tb_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 10:
                  if (inst == "env1") {
                      hostname.innerHTML = event.value;
                  };
                  break;
               case 9:
                  eval("date_"+client+"_"+inst+" = event.value;");
                  break;
               default:
                  break;
            }
         }

         function onLemiValue(topicUri, event) {
            client = getClientname(topicUri);
            inst = getSensorname(topicUri);
            eval("eventcnt_"+client+"_"+inst+" += 1;");             
            event.value = event.value;
            switch (event.id) {
               case 0:
                  eval("time_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               case 1:
                  event.value = event.value.toFixed(2);
                  eval("x_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = x_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_x_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("x_"+client+"_"+inst+"_last = event.value;");
                  eval("line_x_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 2:
                  event.value = event.value.toFixed(2);
                  eval("y_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = y_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_y_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("y_"+client+"_"+inst+"_last = event.value;");
                  eval("line_y_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 3:
                  event.value = event.value.toFixed(2);
                  eval("z_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = z_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_z_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("z_"+client+"_"+inst+"_last = event.value;");
                  eval("line_z_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 5:
                  event.value = event.value.toFixed(2);
                  eval("ta_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = ta_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_ta_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("ta_"+client+"_"+inst+"_last = event.value;");
                  eval("line_ta_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 6:
                  event.value = event.value.toFixed(2);
                  eval("tb_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = tb_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_tb_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("tb_"+client+"_"+inst+"_last = event.value;");
                  eval("line_tb_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               default:
                  break;
            }
         }

         function onPosValue(topicUri, event) {
            client = getClientname(topicUri);
            inst = getSensorname(topicUri);
            eval("eventcnt_"+client+"_"+inst+" += 1;");             
            event.value = event.value;
            switch (event.id) {
               case 4:
                  event.value = event.value.toFixed(2);
                  eval("f_"+client+"_"+inst+".innerHTML = event.value;");
                  eval("var lastval = f_"+client+"_"+inst+"_last;");
                  if (lastval !== null) {
                     eval("line_f_"+client+"_"+inst+".append(new Date().getTime(), lastval);");
                  }
                  eval("f_"+client+"_"+inst+"_last = event.value;");
                  eval("line_f_"+client+"_"+inst+".append(new Date().getTime(), event.value);");
                  break;
               case 0:
                  eval("time_"+client+"_"+inst+".innerHTML = event.value;");
                  break;
               default:
                  break;
            }
         }

      </script>

      <script>

         var sess = null;
         //var wsuri = "ws://192.168.178.21:9100";
         //var client = "europa";
         var wsuri = "ws://193.170.245.145:9100";
         var client = "sedna";
         var retryCount = 0;
         var retryDelay = 2;
         var eventCntUpdateInterval = 2;
         var xaxis = 100;  // Speed


         var sensors = {
             "lemi" : "Lemi025",
             "pos1" : "POS-1",
             "env" : "EnvSensor5"
		}

         var components = {
             "env" : "t,rh",
             "lemi" : "x,y,z,t",
             "pos1" : "f",
             "cs" : "f"
		}

         var parameters = {
             "time" : "",
             "x"    : "nT",
             "y"    : "nT",
             "z"    : "nT",
             "f"    : "nT",
             "ta"   : "deg",
             "tb"   : "deg",
             "t"   : "deg",
             "rh" : "percent",
             "vara" : "percent"
         }

   </script>

      <script>

// ##########################################
// TODO: - Cleanup the event1Cnt variable
//       - Check the remote control functions
// ##########################################
   
         var event1Cnt = 0;
         var event2Cnt = 0;

         // define session variables
         for (var inst in sensors) {
             eval("sess_"+client+" = null;");
             eval("var eventcnt_"+client+"_"+inst+" = null;");
             for (var par in parameters) {
                 eval("var "+par+"_"+client+"_"+inst+" = null;");
                 eval("var line_"+par+"_"+client+"_"+inst+" = new TimeSeries();");
                 eval("var "+par+"_"+client+"_"+inst+"_last = null;");
             }
         }

         // Function for y range in plot
         function myYRangeFunction(range) {
            // TODO implement your calculation using range.min and range.max
            var diff = Math.abs(range.max - range.min); 
            var min = range.min - 3; // - diff*0.05;
            var max = range.max + 3; // + diff*0.05;
            return {min: min, max: max};
            }


         function getClientname(str) {
            var re = str.split("/");
            return re[3];
            }

         function getSensorname(str) {
            var re = str.split("/");
            return re[4].split("#")[1].split("-")[0];
            }


         function createCanvas(sensors) {
             var tab=document.createElement('table');
             tab.setAttribute('id','graphtable');
             tab.className="mytable";
             var tbo=document.createElement('tbody');
             var row, cell, canvastag;
             var nrRows = 4;
             var nrCols = 2;
             for (var inst in sensors) {
                     for (var comp in components) {
                          if (comp == inst) {
                              var str = components[comp];
                              var complst = str.split(",");
                          }
                     };
                     for (var i=0; i<complst.length; i++) {
                         // get the unit:
                         var unit;
                         for (var c in parameters) {
                              if (c == complst[i]) {
                                   unit = parameters[c];
                              };
                         }; 
                         row=document.createElement('tr');
	     	         cell=document.createElement('td');
                         var label = sensors[inst]+": "+complst[i].toUpperCase()+"["+unit+"]";
                         cell.appendChild(document.createTextNode(label));
                         row.appendChild(cell);
  		         cell=document.createElement('td');
              	         canvastag = document.createElement('canvas');
                         if (complst.length < 2) {
		              canvastag.id = "mycanvas_"+inst;
                         } else {
		              canvastag.id = "mycanvas_"+inst+complst[i];
                         };
		         canvastag.width="1000";
                         canvastag.height="150";
		         cell.appendChild(canvastag);
                         row.appendChild(cell);
               	         tbo.appendChild(row);
                     }
             }
             tab.appendChild(tbo);
             return tab;
         }

         function createTable(sensors) {
             var tab=document.createElement('table');
             tab.setAttribute('id','datatable');
             tab.className="mytable";
             var tbo=document.createElement('tbody');
             var row, cell, spantag;
             var nrRows = 4;
             var nrCols = 2;
             row=document.createElement('tr');
             cell=document.createElement('th');
             cell.appendChild(document.createTextNode('SensorID'));
             row.appendChild(cell);
             cell=document.createElement('th');
             cell.appendChild(document.createTextNode('Sensor'));
             row.appendChild(cell);
             //cell=document.createElement('th');
             //cell.appendChild(document.createTextNode('Time'));
             //row.appendChild(cell);
             for (var par in parameters) {
                cell=document.createElement('th');
	        cell.appendChild(document.createTextNode(par));
                row.appendChild(cell);
             	}
             tbo.appendChild(row);
             for(var inst in sensors) {
	         row=document.createElement('tr');
                 cell=document.createElement('td');
		 cell.appendChild(document.createTextNode(inst));
		 row.appendChild(cell);
                 cell=document.createElement('td');
		 cell.appendChild(document.createTextNode(sensors[inst]));
		 row.appendChild(cell);
                 for (var par in parameters) {
                     cell=document.createElement('td');
                     spantag = document.createElement('span');
                     spantag.id = par+"_"+client+"_"+inst;
                     spantag.appendChild(document.createTextNode('-'));
                     cell.appendChild(spantag);
		     row.appendChild(cell);
                 }
	         tbo.appendChild(row);
             }
             tab.appendChild(tbo);
             return tab;
         }

         function hideDetails(divid) {
            document.getElementById(divid).style.display='none';
         }

         function showDetails(divid) {
            document.getElementById(divid).style.display='';
         }

         function controlLed(status) {
            sess.call("rpc:control-led", status).always(ab.log);
         }

         function sendCommand(command) {
            sess.call("rpc:send-command", command).always(ab.log);
         }

         function updateEventCnt() {
            document.getElementById("event1-cnt").innerHTML = Math.round(event1Cnt/eventCntUpdateInterval) + " events/s";
            document.getElementById("event2-cnt").innerHTML = Math.round(event2Cnt/eventCntUpdateInterval) + " events/s";
            event1Cnt = 0;
            event2Cnt = 0;
         }

         function connect() {

            statusline = document.getElementById('statusline');
            
            sess = new ab.Session(wsuri,
               function() {

                  statusline.innerHTML = "Connected to " + wsuri;
                  retryCount = 0;

                  sess.prefix("event", "http://example.com/"+client+"/ow#");
                  for (var inst in sensors) {
                      sess.subscribe("event:"+inst+"-value", onOwValue);
                  }

                  sess.prefix("eventcs", "http://example.com/"+client+"/cs#");
                  sess.subscribe("eventcs:cs1-value", onCsValue);
                  sess.subscribe("eventcs:cs2-value", onCsValue);

                  sess.prefix("event", "http://example.com/"+client+"/env#");
                  sess.subscribe("event:env-value", onEnvValue);

                  sess.prefix("event", "http://example.com/"+client+"/lemi#");
                  sess.subscribe("event:lemi-value", onLemiValue);

                  sess.prefix("event", "http://example.com/"+client+"/pos1#");
                  sess.subscribe("event:pos1-value", onPosValue);

                  sess.prefix("rpc", "http://example.com/"+client+"/env1-control#");

                  event1Cnt = 0;
                  
                  window.setInterval(updateEventCnt, eventCntUpdateInterval * 1000);
               },
               function() {
                  console.log(retryCount);
                  retryCount = retryCount + 1;
                  statusline.innerHTML = "Connection lost. Reconnecting (" + retryCount + ") in " + retryDelay + " secs ..";
                  window.setTimeout(connect, retryDelay * 1000);
               }
            );

         }


         window.onload = function ()
         {
            document.getElementById('table1div').appendChild(createTable(sensors));
            document.getElementById('table2div').appendChild(createCanvas(sensors));
            document.getElementById('client').innerHTML = client;

            for (var inst in sensors) {
                for (var par in parameters) {
                    eval(par+"_"+client+"_"+inst+" = document.getElementById('"+par+"_"+client+"_"+inst+"');");
                }
            }

            for (var inst in sensors) {
                    for (var comp in components) {
                          var str = components[comp];
                          var complst = str.split(",");
                          if (complst.length < 2) {
                                   eval("var smoothie_"+inst+" = new SmoothieChart({grid: {strokeStyle: '#777777',fillStyle: '#253529',lineWidth: 0.2,millisPerLine: 10000, verticalSections: 10},labels: {fontSize: 15,fontFamily: 'sans-serif',precision: 1},timestampFormatter:SmoothieChart.timeFormatter,yRangeFunction:myYRangeFunction,millisPerPixel: xaxis,resetBounds: false,interpolation: 'bezier'});");
                                   }
                          else {
                                   for (var i=0; i<complst.length; i++) {
                                         eval("var smoothie_"+inst+complst[i]+" = new SmoothieChart({grid: {strokeStyle: '#777777',fillStyle: '#253529',lineWidth: 0.2,millisPerLine: 10000, verticalSections: 10},labels: {fontSize: 15,fontFamily: 'sans-serif',precision: 1},timestampFormatter:SmoothieChart.timeFormatter,yRangeFunction:myYRangeFunction,millisPerPixel: xaxis,resetBounds: false,interpolation: 'bezier'});");
                                         };
                                    }
                           }
		    };

            for (var inst in sensors) {
                if (inst.substring(0,3) == "env") {
                    eval("smoothie_"+inst+"t.addTimeSeries(line_ta_"+client+"_"+inst+", { strokeStyle: 'rgb(205,79,57)', fillStyle: 'rgba(205,79,57, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"t.addTimeSeries(line_tb_"+client+"_"+inst+", { strokeStyle: 'rgb(205,255,57)', fillStyle: 'rgba(205,255,57, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"rh.addTimeSeries(line_vara_"+client+"_"+inst+", { strokeStyle: 'rgb(171,130,255)', fillStyle: 'rgba(171,130,255, 0.3)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"t.streamTo(document.getElementById('mycanvas_"+inst+"t'));");
                    eval("smoothie_"+inst+"rh.streamTo(document.getElementById('mycanvas_"+inst+"rh'));");
                }
                else if (inst.substring(0,3) == "pos") {
                    eval("smoothie_"+inst+".addTimeSeries(line_f_"+client+"_"+inst+", { strokeStyle: '	rgb(179, 68, 108)', fillStyle: 'rgba(179, 68, 108, 0.3)', lineWidth: 3 });");
                    eval("smoothie_"+inst+".streamTo(document.getElementById('mycanvas_"+inst+"'));");
                }
                else if (inst.substring(0,3) == "lem") {
                    eval("smoothie_"+inst+"x.addTimeSeries(line_x_"+client+"_"+inst+", { strokeStyle: 'rgb(205,79,57)', fillStyle: 'rgba(205,79,57, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"x.streamTo(document.getElementById('mycanvas_"+inst+"x'));");
                    eval("smoothie_"+inst+"y.addTimeSeries(line_y_"+client+"_"+inst+", { strokeStyle: 'rgb(205,255,57)', fillStyle: 'rgba(205,255,57, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"y.streamTo(document.getElementById('mycanvas_"+inst+"y'));");
                    eval("smoothie_"+inst+"z.addTimeSeries(line_z_"+client+"_"+inst+", { strokeStyle: 'rgb(171,130,255)', fillStyle: 'rgba(171,130,255, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"z.streamTo(document.getElementById('mycanvas_"+inst+"z'));");
                    eval("smoothie_"+inst+"t.addTimeSeries(line_tb_"+client+"_"+inst+", { strokeStyle: 'rgb(255, 127, 80)', fillStyle: 'rgba(255, 127, 80, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"t.addTimeSeries(line_ta_"+client+"_"+inst+", { strokeStyle: 'rgb(245, 199, 26)', fillStyle: 'rgba(245, 199, 26, 0.1)', lineWidth: 3 });");
                    eval("smoothie_"+inst+"t.streamTo(document.getElementById('mycanvas_"+inst+"t'));");
                }
                else if (sensors[inst].substring(0,2) == "DS") {
                    eval("smoothie_"+inst+".addTimeSeries(line_t_"+client+"_"+inst+", { strokeStyle: 'rgb(205,79,57)', fillStyle: 'rgba(205,79,57, 0.3)', lineWidth: 3 });");
                    eval("smoothie_"+inst+".streamTo(document.getElementById('mycanvas_"+inst+"'));");
                }
            }

            connect();

         };

   </script>

   </head>
   <body bgcolor="#FAF0BE">
      <center>
      <h2>Geomagnetic field variation from <span id="client">-</span> - LIVE</h2>
      <center>
      <div id="table2div"></div>
      </center>

      <center>
      <h2>Current values - LIVE</h2>
      <div id="table1div"></div>
      </center>

      <h2>Status</h2>
      <div id="statusline"></div>

   </body>
 </html>
